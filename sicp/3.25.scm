(define (make-table predicat)
  (let ((table (cons `*table*
		     `()))
	(key-eq? predicat))
    (define (element-of table)
      (cond ((pair? table) (element-of (cdr table)))
	    (else table)))
    (define (lookup key)
      (define (lookup-iter key-list table key-eq?)
	(if table
	    (let ((subtable (assoc (car key-list)
				   (cdr table)
				   key-eq?)))
	      (if (null? (cdr key-list))
		  (element-of subtable)
		  (lookup-iter (cdr key-list)
			       subtable
			       key-eq?)))
	    #f))
      (lookup-iter key table key-eq?))
    (define (insert! item key)
      (define (insert-iter key-list table item)
	(if (null? (cdr key-list))
	    (let ((record (assoc (car key-list)
				 (cdr table)
				 key-eq?)))
	      (if record
		  (set-cdr! record item)
		  (set-cdr! table (cons (cons (car key-list)
					      item)
					(cdr table)))))
	    (let ((subtable (assoc (car key-list)
				   (cdr table)
				   key-eq?)))
	      (if subtable
		  (insert-iter (cdr key-list)
			       subtable
			       item)
		  (begin (set-cdr! table
				   (cons (cons (car key-list)
					       `())
					 (cdr table)))
			 (insert-iter (cdr key-list)
				      (caar table)
				      item))))))
      (insert-iter key table item))
    (define (dispatch m)
      (cond ((eq? m `lookup) lookup)
	    ((eq? m `insert!) insert!)
	    (else "Error")))
    dispatch))

(define (lookup table . key) ((table `lookup) key))
(define (insert! table item . k) ((table `insert!) item k))

(define (assoc key records predicat)
  (cond ((null? records) #f)
	((not (pair? records)) #f)
        ((predicat key (caar records)) (car records))
        (else (assoc key (cdr records) predicat))))
